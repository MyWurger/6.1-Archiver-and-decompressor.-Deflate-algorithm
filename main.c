#include <stdio.h>                   // подключение стандартной библиотеки ввода/вывода
#include <stdlib.h>                  // содержит в себе функции, занимающиеся выделением памяти
#include <string.h>                  // функции для работы со строками
#include <stdbool.h>                 // функции для работы с типом данных bool
#include <dirent.h>                  // содержит объявления функций и структур данных, необходимых для работы с файловой системой и директориями
#include <unistd.h>                  // содержит символические константы и структуры, которые еще не были описаны в каких-либо других включаемых файлах
#include <sys/stat.h>                // вносит в структуру, на которую указывает statbuf, информацию, содержащуюся в файле, связанном с указателем filename
#include <time.h>                    // для работы со временем

/***************************************************/
/*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
/***************************************************/

/*----------------------------------------------------------------------*/
/* Получение размера файла и считывание информации из него */
/*---------------------------------------------------------*/

int Get_Size (const char * filenameIN,             // путь до файла, размер которого определяется или из которого считывается информация
              FILE * FilenameOUT)                  // указатель на файл, куда будет записываться считанная информация
{
    FILE * inFile = fopen(filenameIN, "rb");       // открываем файл для чтения в бинарном режиме

    // ошибка открытия файла
    if (inFile == NULL)
    {
        printf ("\n\033[35m ОШИБКА открытия файла чтения \"%s\". Код ошибки -1 \033[0m\n", filenameIN);

        return -1;                                 // возвращаем -1 по соответствию с кодом ошибки
    }// if

    fseek(inFile, 0, SEEK_END);                    // устанавливаем указатель файла в конец
    int file_size = ftell(inFile);                 // получаем размер файла в байтах
    fseek(inFile, 0, SEEK_SET);                    // возвращаем указатель файла в начало

    // Выделяем память под буфер (количество байтов файла, умноженное на размер типа char в байтах)
    char *buffer = (char *)malloc(file_size * sizeof(char));

    // считываем данные из файла в буфер по байтам
    // данные сохранятся в буфер, считывание по 1 байту. Количество считываемых символов file_size из inFile
    size_t num_bytes = fread(buffer, 1, file_size, inFile);

    // ошибка будет, если прочитано ноль байт, не был достигнут конец файла и количество символов, считанное функцией, не совпадает с подсчитанным вручную
    if (num_bytes == 0 && !feof(inFile) && num_bytes!=file_size)
    {
        printf("\n\033[35m ОШИБКА чтения файла %s. Код ошибки -2 \033[0m\n", filenameIN);
       
        return -2;                                 // возвращаем -2 по соответствию с кодом ошибки       
    }// if

    fclose(inFile);                                // файл чтения отработан - закрываем его
    fwrite(buffer, 1, num_bytes, FilenameOUT);     // записываем данные из буфера в файл вывода. Аргументы, аналогичные fread

    // дополнительно записываем дату и время работы, если filenameIN - текстовый файл
    char *txt_ext = ".txt";                        // объявление переменной txt_ext типа "указатель на символ"
    int filenameIN_len = strlen(filenameIN);       // размер пути до файла считывания
    int txt_ext_len = strlen(txt_ext);             // значение, равное длине строки txt_ext, которая представляет расширение файла .txt.
   
    // длина имени файла (filenameIN_len) больше или равна длине расширения .txt (txt_ext_len).
    // Если это условие не выполняется, значит длина имени файла слишком короткая, чтобы содержать
    // расширение .txt, и дальнейшая проверка не имеет смысла

    // сравнивает часть имени файла, начиная с позиции filenameIN_len - txt_ext_len и имеющей длину txt_ext_len, с расширением .txt (txt_ext)
    if (filenameIN_len >= txt_ext_len && strcmp(filenameIN + filenameIN_len - txt_ext_len, txt_ext) == 0) 
    {
        time_t now = time(NULL);
        struct tm *local_time = localtime(&now);   // получение локального времени

        // запись полей структуры локального времени в выходной файл
        fprintf(FilenameOUT, "Дата и время архивации: %02d/%02d/%04d %02d:%02d:%02d",
        local_time->tm_mday, local_time->tm_mon + 1, local_time->tm_year + 1900,
        local_time->tm_hour, local_time->tm_min, local_time->tm_sec);

    }// if (filenameIN_len >= txt_ext_len && strcmp(filenameIN + filenameIN_len - txt_ext_len, txt_ext) == 0) 

    // последовательность "*****" в конец записи информации из очередного файла
    const char *sequence = "\n*****\n";

    // записываем последовательность-разделитель в файл вывода
    fwrite(sequence, sizeof(char), strlen(sequence), FilenameOUT);

    free(buffer);                                  // освобождаем память, выделенную для буфера
    return num_bytes;                              // возвращаем количество байтов, которые занимает информация из очередного файла
}



/*----------------------------------------------------------------------*/
/*    Получение размера директории    */
/*------------------------------------*/

int Get_Folder_Size(const char* folderPath)        // путь до файла, размер которого определяется или из которого считывается информация
{
    DIR* dir;                                      // идентификатор каталога
    struct dirent* entry;                          // указатель на структуру сведений о файле или поддиректории
    struct stat fileStat;                          // структура, хранящая информацию о сведениях о файле или поддиректории
    double totalSize = 0;                          // общий размер каталога
    
    dir = opendir(folderPath);                     // открываем каталог по заданному пути

    // ошибка открытия каталога
    if (dir == NULL) 
    {
        printf("\n\033[35m Ошибка открытия каталога: %s. Код ошибки -4 \033[0m\n", folderPath);

        return -4;                                 // возвращаем -4 по соответствию с кодом ошибки
    }// if(dir == NULL) 
    
    // читаем содержимое каталога
    while ((entry = readdir(dir)) != NULL) 
    {
        char filePath[1024];
        // формируем полный путь к файлу или каталогу, добавляя его имя к folderPath с разделителем / и записывая результат в filePath.
        snprintf(filePath, sizeof(filePath), "%s/%s", folderPath, entry->d_name);

        // информация о файле/каталоге получена успешно
        if (lstat(filePath, &fileStat) == 0) 
        {
            // проверяем, является ли текущий элемент каталогом
            if (S_ISDIR(fileStat.st_mode)) 
            {
                // исключаем текущий и родительский каталоги
                if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) 
                { 
                    // рекурсивно вызываем функцию для подкаталога. В dirSize будет содержаться размер дочерней директории
                    double dirSize = Get_Folder_Size(filePath);
                    
                    // ошибка во время вычисления размера подкаталога
                    if (dirSize == -1) 
                    {
                        // закрываем дескриптор каталога `dir`
                        closedir(dir);

                        return -1;
                    }// if(dirSize == -1) 
                    totalSize += dirSize;          // увеличиваем общий размер каталога

                }// if(strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) 
            
            }

            // элемент - файл
            else 
            {
                totalSize += fileStat.st_size;     // увеличиваем общий размер файла размером файла
            }// if(S_ISDIR(fileStat.st_mode)) 
        }

        // информация о файле/каталоге недоступна
        else 
        {
            printf("\n\033[35m Ошибка получения информации о файле: %s. Код ошибки -5 \033[0m\n", filePath);
        }// if(stat(filePath, &fileStat) == 0) 

    }// while()
    
    closedir(dir);      // закрываем каталог
    return totalSize;   // возвращаем общий размер каталога
}



/*----------------------------------------------------------------------*/
/*   Изменение директории с файлами архивации    */
/*-----------------------------------------------*/

void changeDirectory(char* dir,                    // указатель на первый элемент массива с адресом рабочей директории
                     const char* path)             // директория с адресом файла по умолчанию
{
    char choice[10];                               // хочет ли пользователь изменять директорию с файлами

    // бесконечный цикл выбора
    while (true) 
    {
        printf(" Хотите изменить директорию? (Y/N): ");
        scanf("%9s", choice);                      // считывание пользовательского выбора

        // пользователь хочет изменить директорию ввода
        if ((strcmp(choice, "Y") == 0) || (strcmp(choice, "y") == 0)) 
        {
            printf(" Введите новый адрес директории: ");
            scanf("%99s", dir);                    // ввод новой директории, указанной пользователем

            // проверка на существование директории по адресу пользователя
            if(opendir(dir) != NULL)
            {
                printf(" Директория существует.\n");

                // указанная пользователем директория доступна для записи и не является директорией, в которую запрещено записывать файлы ("/" и "/home")
                if ((access(dir, W_OK) == 0) && (strcmp(dir, "/") != 0) && (strcmp(dir, "/home")) != 0)
                {
                    printf(" Директория доступна для записи.\n");
                    break;                         // завершаем цикл просьбы ввода. Директория указанная пользователем всех устраивает
                }

                // директория недоступна для записи или в ней нельзя создать файлы
                else 
                {
                    printf("\033[33m Директория недоступна для записи. Попробуйте заново. \033[0m\n");
                    printf("\n *****\n\n");

                    // в начало цикла для повтора ввода адреса заново
                    continue;
                }// if((access(dir, W_OK) == 0) && (strcmp(dir, "/") != 0) && (strcmp(dir, "/home")) != 0)
            }

            // пользовательской директории не существует
            else 
            {
                printf("\033[32m Директория не существует. Попробуйте заново. \033[0m\n");
                printf("\n *****\n\n");
            }// if(opendir(dir) != NULL)
        }

        // выбрана пользователем директория по умолчанию
        else 
        {
            strcpy(dir, path);
            break;
        }// if((strcmp(choice, "Y") == 0) || (strcmp(choice, "y") == 0)) 

    }// while(true) 

    printf (" Директория работы: %s успешно сохранена\n", dir);
    return;                                        // вернули обещанное функцией значение
}



/*----------------------------------------------------------------------*/
/* Определение индекса последнего вхождения символа  */
/*---------------------------------------------------*/

int find_last_occurrence(const char *str,          // строка, в которой ищем последнее вхождение символа 
                         char ch,                  // символ, который ищем
                         int *last_nonzero_index)  // индекс последнего ненулевого символа строки
{
    int last_index = -1;                           // индекс последнего вхождения элемента поиска, изначально устанавливаем -1
    int i;                                         // для цикла

    // проходим по каждому символу строки, пока не достигнем конца строки
    for (i = 0; str[i] != '\0'; i++) 
    {
        // если текущий символ равен заданному символу поиска
        if (str[i] == ch)
        {
           last_index = i;                         // устанавливаем индекс последнего вхождения
        }// if(str[i] == ch)

    }// for i

    // индекс элемента '\0' устанавливаем в соответствующую для него переменную
    *last_nonzero_index = i;
    return last_index;                             // возвращаем индекс последнего вхождения символа поиска
}



/*----------------------------------------------------------------------*/
/*    Создание директори     */
/*---------------------------*/

void create_directory(char* path,                 // путь к директории создания
                      const char* extension)      // расширение с названием создаваемой директории    
{
    strcat(path, extension);
    // директория для загрузки временных файлов не существует
    if(opendir(path) == NULL)
    {
        // создание директории для загрузки временных файлов
        int result = mkdir(path, 0777);            // 0777 - права доступа

        // создание успешно
        if (result == 0) 
        {
            return ;                               // выходим из функции - возвращаем обещанное значение
        } 

        // ошибка создания директории
        else 
        {
            printf("\n\033[35m ОШИБКА создания новой директории. Код ошибки -6.\033[0m\n\n");
            exit(0);                               // завершение программы из функции
        }// if(result == 0) 
    }

    // директория уже существует
    else
    {
        printf(" Директория уже существует \n");
        return ;                                   // выходим из функции - возвращаем обещанное значение
    }// if(opendir(path) == NULL)
    return;                                        // возвращаем обещанное значение
}



/*----------------------------------------------------------------------*/
/*    Удаление директории с файлами     */
/*--------------------------------------*/

void remove_directory(const char* path)            // путь к каталогу для удаления           
{
    // удаление проходит рекурсивно, начиная с вложенных файлов и папок

    DIR *dir = opendir(path);                      // открываем каталог по заданному пути
    struct dirent *entry;                          // указатель на структуру сведений о файле или поддиректории

    // ошибка открытия каталога
    if (dir == NULL) 
    {
        printf("Ошибка открытия каталога: %s. Код ошибки -4\n\n", path);
        exit(0);                                   // аварийное завершение программы из функции. Далее продолжать не имеет смысла
    }// if(dir == NULL)

    // читаем содержимое каталога
    while ((entry = readdir(dir)) != NULL) 
    {
        char file_path[1024];
        // формируем полный путь к файлу или каталогу, добавляя его имя к path с разделителем / и записывая результат в filePath.
        snprintf(file_path, sizeof(file_path), "%s/%s", path, entry->d_name);
        struct stat statbuf;                       // структура, содержащая информацию о файле/каталоге
        
        // ошибка получения данных в statbuf
        if (lstat(file_path, &statbuf) == -1) 
        {
            continue;                              // читаем дальше
        }// if(stat(file_path, &statbuf) == -1)  

        // проверяем, является ли текущий элемент каталогом
        if (S_ISDIR(statbuf.st_mode)) 
        {
            // исключаем текущий и родительский каталоги
            if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) 
            {   
                // вызываем функцию удаления для подкаталога
                remove_directory(file_path);
            }// if(strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
        } 
        
        // текущий элемент - файл
        else 
        {
            // удаляем файл по текущему пути
            remove(file_path);
        }// if(S_ISDIR(statbuf.st_mode)) 

    }// while()

    closedir(dir);                                 // закрываем каталог
    rmdir(path);                                   // удаляем пустой каталог
    return;                                        // возвращаем обещанное значение
}



/*----------------------------------------------------------------------*/
/*     Печать директории с файлами и подсчет файлов    */
/*-----------------------------------------------------*/

void print_dir(char *dir,                          // путь до файла/каталога печати
               int depth,                          // глубина - параметр для вывода отступов
               int *count_files)                   // количество файлов, но не каталогов
{
    DIR *dp;                                       // идентификатор каталога
    struct dirent *entry;                          // указатель на структуру сведений о файле или поддиректории
    struct stat statbuf;                           // структура, содержащая информацию о файле/каталоге

    // ошибка открытия каталога
    if((dp = opendir(dir)) == NULL)
    {
        printf("Ошибка открытия существующего файла: %s. Код ошибки -5\n\n", dir);
        return;                                    // выходим из функции - возвращаем обещанное значение. Программа может продолжаться
    }// if((dp = opendir(dir)) == NULL)

    chdir(dir);                                    // меняем рабочий каталог

    // читаем содержимое каталога
    while ((entry = readdir(dp)) != NULL)
    {
        // получение данных в statbuf
        lstat(entry->d_name, &statbuf);

        // является ли очередной элемент каталогом
        if(S_ISDIR(statbuf.st_mode))
        {
            // исключаем текущий и родительский каталоги
            if(strcmp(".", entry->d_name) == 0 || strcmp("..", entry->d_name) == 0)
            {
                continue;
            }// if(strcmp(".", entry->d_name) == 0 || strcmp("..", entry->d_name) == 0)

            // печатаем каталог
            printf(" %*s%s/\n", depth, "", entry->d_name);
            // Рекурсивынй вызов с новым доступом после игнорирования текущего и родительского каталога
            print_dir(entry->d_name, depth+4, count_files);
        }

        // если не каталог, то файл. Увеличиваем счётчик файлов и выводим название файла
        else
        {
            *count_files = *count_files + 1;
            printf("%*s%s\n", depth, " ", entry->d_name);
        }//  if(S_ISDIR(statbuf.st_mode))
    
    }// while()

    chdir("..");                                   // как только while заканчиваются, вызов chdir("..") возвращает программу вверх по дереву каталогов
    closedir(dp);                                  // закрытие текущего каталога
    return;                                        // возвращаем обещанное значение
}



/*----------------------------------------------------------------------*/
/* Сканирование директории и обработка элементов в ней  */
/*------------------------------------------------------*/

void scanDirectory(const char *dir,                // путь к сканируемой директории
                   char work_directory[100],       // название сканируемой директории
                   FILE **gen_arch,                // информация о файлах
                   FILE **data_arch,               // данные, хранящиеся в файлах
                   FILE **way_arch)                // информация о каталогах
{
    DIR *dp;                                       // идентификатор каталога
    struct dirent *entry;                          // указатель на структуру сведений о файле или поддиректории
    struct stat statbuf;                           // структура, содержащая информацию о файле/каталоге

    // ошибка открытия каталога
    if((dp = opendir(dir)) == NULL)
    {
        printf("\n\033[35m ОШИБКА открытия существующей директории %s. Код ошибки -9.\033[0m\n\n", dir);
        return;                                    // выходим из функции - возвращаем обещанное значение. Программа может продолжаться
    }// if((dp = opendir(dir)) == NULL)

    chdir(dir);                                    // меняем рабочий каталог

    // читаем содержимое каталога
    while ((entry = readdir(dp)) != NULL)
    {
        // получение данных в statbuf
        lstat(entry->d_name, &statbuf);

        char way[256];                             // построение пути до элемента
        memset(way, 0, sizeof(way));               // очистка массива
        strcpy(way, work_directory);               // копируем имя начального каталога архива с расширением ".linrar". Отправная точка для построения путей
        strcat(way, "/");                       
        strcat(way, entry->d_name);                // получаем путь до текущего файла/каталога, прибавляя его имя

        // является ли очередной элемент каталогом
        if(S_ISDIR(statbuf.st_mode))
        {
            // Пропустить текущую и родительскую директории, а также директорию "sources"
            if(strcmp(".", entry->d_name) == 0 || strcmp("..", entry->d_name) == 0 || strcmp("sources", entry->d_name) == 0)
            {
                continue;                          // пропускаем
            }//  if(strcmp(".", entry->d_name) == 0 || strcmp("..", entry->d_name) == 0 || strcmp("sources", entry->d_name) == 0)

            printf(" %s\n", way);                  // печать построенного пути до директории
            // получение размера директории
            int size = Get_Folder_Size(entry->d_name);
            printf(" Размер директории: %i байтов\n", size);
            printf(" Тип: ДИРЕКТОРИЯ\n\n");
            // запись во вспомогательный файл директории названия, размера и пути до него в архиве
            fprintf(*way_arch, "%s, %i, %s\n", entry->d_name, size, way);
            // рекурсивынй вызов с новым доступом
            scanDirectory(entry->d_name, way, gen_arch, data_arch, way_arch);
        }

        // рассматриваем файл
        else
        {
            printf(" %s\n", way);                  // печать построенного пути до файла
            // получение размера файла
            int size = Get_Size(entry->d_name, *data_arch);
            printf(" Размер файла: %i байтов\n", size);
            printf(" Тип: ФАЙЛ\n\n");
            // запись во вспомогательный файл файла названия, размера и пути до него в архиве
            fprintf(*gen_arch, "%s, %i, %s\n", entry->d_name, size, way);

        }// if(S_ISDIR(statbuf.st_mode))

    }//while()

    chdir("..");                                   // как только while заканчиваются, вызов chdir("..") возвращает программу вверх по дереву каталогов
    closedir(dp);                                  // закрытие текущего каталога
    return ;                                       // возвращаем обещанное значение
}



/*----------------------------------------------------------------------*/
/*     запись из файла источника в сток     */
/*------------------------------------------*/

void transfer_content(FILE *src,                   // указатель на файл-источник, из которого будет считываться содержимое
                      FILE *dst)                   // указатель на целевой файл, в который будет записываться содержимое
{
    char buffer[1024];                             // хранитcя временно считываемое содержимое из файла src
    size_t bytes_read;                             // количество байтов, считанных из файла src на каждой итерации цикла

    // читаем содержимое и записываем в целевой файл, пока не достигли конца файла
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), src)) > 0) 
    {
        // запись считанного содержимого поблочно в файл dst
        fwrite(buffer, 1, bytes_read, dst);
    }// while()

    return;                                        // возвращаем обещанное значение
}


/*----------------------------------------------------------------------*/
/*     получение пароля на архив    */
/*----------------------------------*/

void getpassword(char *password)                   // строка хранения пароля    
{
    printf("\033[38;5;150m Хотите изменить пароль на архив? (Y/N): \033[0m");
    char choice[100];                                // выбор пользователя
    memset(choice, 0, sizeof(choice));             // очистка массива выбора пользователя
    scanf(" %s", choice);
   
    // бесконечный цикл ввода пароля
    while(true)
    {
        if((strlen(choice) == 1))                  // в ответе пользователя должна содержаться одна буква
        {
            // пользователь захотел поменять пароль
            if (choice[0] == 'y' || choice[0] == 'Y') 
            {
                printf(" Введите пароль: ");
                scanf("%s", password);             // ввод пароля пользователем
                break;                             // прерываем цикл - пароль установлен
            }

            // пользователь выбрал не менять пароль
            else if (choice[0] == 'N' || choice[0] == 'n')
            {
                printf(" Пароль на архив оставлен по умолчанию\n");
                strcpy(password, "qwerty123");      // установка пароля по умолчанию
                break;                              // прерываем цикл - пароль установлен
            }

            // пользователь ввел неправильную букву выбора
            else
            {
                printf(" Попробуйте ввести выбор заново\n ");
                printf("*****\n");
                printf("\033[38;5;150m Хотите изменить пароль на архив? (Y/N): \033[0m");
                memset(choice, 0, sizeof(choice)); // очистка массива выбора ввода
                scanf("%s", choice);               // просим повторить ввод - цикл начинается заново
            }// if
        }

        // пользователь ввел несколько символов при выборе
        else
        {   
            printf(" Попробуйте ввести выбор заново\n ");
            printf("*****\n");
            printf("\033[38;5;150m Хотите изменить пароль на архив? (Y/N): \033[0m");
            memset(choice, 0, sizeof(choice));     // очистка массива выбора ввода
            scanf("%s", choice);                   // просим повторить ввод - цикл начинается заново
        }// if((strlen(choice) == 1))

    }// while()

    return;                                        // вернули обещанное значение
}



/*----------------------------------------------------------------------*/
/*     Архиватор    */
/*------------------*/

void archiver()
{
    char directory[256];                           // директория для работы
    char directory_copy[256];                      // копия директории для работы
    char work_directory[100];                      // название рабочей директории
    char before_work[256];                         // путь до рабочей директории
    char etc[4] = "../";                           // для канкатенации путей
    int j = 1;                                     // вспомогательный индекс для копирования названия
    int last_index = -1;                           // индекс последнего вхождения символа поиска
    int last_nonzero_index = -1;                   // индекс последнего символа строки
    int count_files = 0;                           // количество файлов в директории, не считая каталогов

    memset(directory, 0, sizeof(directory));           // очистка массива директории работы
    memset(directory_copy, 0, sizeof(directory_copy)); // очистка массива копии директории работы 
    memset(work_directory, 0, sizeof(work_directory)); // очистка массива названия рабочей директории
    memset(before_work, 0, sizeof(before_work));       // очистка массива пути до рабочей директории

    // Просто работа с текстовыми путями
    // gen_arch[0][256]  - информация о файлах и их размерах
    // data_arch[1][256] - данные из файлов
    // way_arch[2][256]  - пути папок в рассматриваемой директории
    // rest_arch[3][256] - итоговый файл архива
    char info_arch[4][256];                            // многомерный массив для работы с файлами ресурсов

    // устанавливаем директорию для работы
    changeDirectory(directory, "/home/dmitru/Lab_Examples/Lab1");
    // копируем установленную пользователем директорию
    strcpy(directory_copy, directory);

    // выводим рабочую директорию, выбранную пользователем
    printf("\033[38;5;111m Текущая рабочая директория: %s\n\033[0m", directory);
    printf("\n\t\t\t\t\t   \033[35m Работа с архивом\033[0m\n\n");

    // проходим по многомерному массиву - чистим его и заполняем шаблоном с директорией, в которой находятся сжимаемые файлы
    for(int i=0; i < sizeof(info_arch) / sizeof(info_arch[0]); i++)
    {
        // очистка массива
        strcpy(info_arch[i], ""); 
        // заполнение адресом рабочей директории
        strcat(info_arch[i], directory);
    }// for i

    // Определение индекса, с которого начинается название рабочей директории и индекса последнего символа в названии
    last_index = find_last_occurrence(directory, '/', &last_nonzero_index);
   
    // индексы, необходимые для дальнейших вычислений, найдены неверно 
    if((last_index == -1) || (last_nonzero_index == -1))
    {
        printf("\n\033[35m ОШИБКА нахождения индексов. Повторите ввод. Код ошибки -6.\033[0m");
        exit(0);
    }// if((last_index == -1) || (last_nonzero_index == -1))

    // выводим вычисленные индексы на экран
    printf(" Индекс последнего элемента в строке адреса: %i\n", last_nonzero_index);
    printf(" Индекс последнего вхождения элемента \\ в строку: %i\n", last_index);

    // создаём вспомогательную директорию, в которой хранятся вспомогательные файлы
    create_directory(directory, "/sources"); 
    printf(" Вспомогательная директория успешно создана\n");
    
    // выделим название рабочей директории для архивации
    // название рабочей директории - символы между последним '\' и концом строки
    for(int i = 0; i < (last_nonzero_index - last_index) - 1; i++)
    {
        work_directory[i] = directory[last_index + j]; // запоминаем элементы после последнего символа '/' в отдельный массив
        j = j+1;                                       // перемещаемся по массиву названия рабочей дирректории
    }// for i

    // запоминаем путь до рабочей директории до названия рабочей папки
    for(int i = 0; i <= last_index - 1; i++)
    {
        // поэлементное копирование части массива пути
        before_work[i] = directory[i];
    }// for i

    // надбавки к имеющимся путям для создания вспомогательных файлов
    char files[3][16] = 
    {
        "/info_arch.txt",
        "/data_arch.txt",
        "/way_arch.txt"
    };

    // очищаем последний элемент многомерного массива
    strcpy(info_arch[3], "");
    // помещаем туда путь до рабочей директории. Файл архива создаётся на уровне с рабочим каталогом, а не в нем
    strcat(info_arch[3],  before_work);

    printf("\n ----- \n");
    // выводим путь до рабочего каталога
    printf("\n Путь до рабочей папки: %s", before_work);
    // выводим название рабочего каталога
    printf("\n Рабочая папка в директории: %s\n", work_directory);
    printf("\n\033[38;5;177m Путь, где создадутся новые информационные файлы и файл архива: \033[0m\n");
    
    // определяем пути для создания вспомогательных файлов
    // идём по строчкам многомерного массива
    for(int i=0; i < sizeof(info_arch) / sizeof(info_arch[0]); i++)
    {
        // все файлы до архива находятся в папке "sources"
        if(i!=3)
        {
            // добавляем в путь папку "sources"
            strcat(info_arch[i], "/sources");
            // соединяем новый путь с названиями файлов
            strcat(info_arch[i], files[i]);
        }

        // работа с путём файла архива
        else
        {
            // определяем путь до файла архива на уровень выше, чем рабочий каталог. Название архива представляет собой "Название_рабочего каталога.linrar"
            strcat(strcat(info_arch[i], "/"), strcat(work_directory, ".linrar"));
        }// if(i!=3)

        // печатаем полученные пути до вспомогательных файлов и файла архива
        printf(" %i %s\n", i, info_arch[i]);
    }// for i


    // работа непосредственно с файлами
    // открытие для записи информации о файлах и их размерах и путях
    FILE *gen_arch = fopen(info_arch[0], "wb");

    // ошибка открытия. Аварийное завершение
    if (gen_arch == NULL) 
    {
        printf("\n\033[35m ОШИБКА открытия файла записи \"%s\". Код ошибки -7 \033[0m", info_arch);
        exit (0);
    }// if(gen_arch == NULL) 

    // открытие для записи данных из файлов
    FILE *data_arch = fopen(info_arch[1], "wb");
    // ошибка открытия. Аварийное завершение
    if (data_arch == NULL) 
    {
        printf("\n\033[35m ОШИБКА открытия файла записи \"%s\". Код ошибки -7 \033[0m", data_arch);
        exit (0);
    }// if (data_arch == NULL) 

    // открытие для записи путей и названий каталогов в рассматриваемой директории
    FILE *way_arch = fopen(info_arch[2], "wb");
    // ошибка открытия. Аварийное завершение
    if (way_arch == NULL) 
    {
        printf("\n\033[35m ОШИБКА открытия файла записи \"%s\". Код ошибки -7 \033[0m", way_arch);
        exit (0);
    }// if (way_arch == NULL)

    // печать иерархии каталогов и файлов в рассматриваемой директории
    printf("\n\033[38;5;161m Файлы в рабочей директории: \033[0m\n");
    print_dir(directory_copy, 0, &count_files);
    printf("\n");

    // запись информации во вспомогательные файлы
    printf("\033[38;5;166m Каталоги и файлы архива: \033[0m\n");
    scanDirectory(directory_copy, work_directory, &gen_arch, &data_arch, &way_arch);
    
    // закрытие вспомогательных файлов, чтобы в них отобразилась записанная в функции информация
    fclose(gen_arch);
    fclose(data_arch);
    fclose(way_arch);

    // открытие для чтения данных из файлов
    gen_arch = fopen(info_arch[0], "rb");
    // ошибка открытия. Аварийное завершение
    if (gen_arch == NULL) 
    {
        printf("\n\033[35m ОШИБКА открытия файла чтения \"%s\". Код ошибки -8 \033[0m", info_arch);
        exit (0);
    }// if (gen_arch == NULL) 

    // открытие для чтения данных из файлов
    data_arch = fopen(info_arch[1], "rb");
    // ошибка открытия. Аварийное завершение
    if (data_arch == NULL) 
    {
        printf("\n\033[35m ОШИБКА открытия файла чтения \"%s\". Код ошибки -8 \033[0m", data_arch);
        exit (0);
    }// if (data_arch == NULL) 

    // открытие для чтения путей папок в рассматриваемой директории
    way_arch = fopen(info_arch[2], "rb");
    // ошибка открытия. Аварийное завершение
    if (way_arch == NULL) 
    {
        printf("\n\033[35m ОШИБКА открытия файла чтения \"%s\". Код ошибки -8 \033[0m", way_arch);
        exit (0);
    }// if (way_arch == NULL) 

    // открытие для записи информации в архив
    FILE *rest_arch = fopen(info_arch[3], "wb");
    // ошибка открытия. Аварийное завершение
    if (rest_arch == NULL) 
    {
        printf(" ОШИБКА открытия файла записи \"%s\". Код ошибки -7\n", rest_arch);
        exit (0);
    }// if (rest_arch == NULL) 

    char password[100];                                // пароль для архива
    memset(password, 0, sizeof(password));             // очистка массива с паролем для архива
    getpassword(password);                             // получаем пароль на архив
    printf("\n\033[38;5;50m Установлен пароль на архив: %s \033[0m\n\n", password);
    strcat(password, "\n");                            // устанавливаем, чтобы в строке содержался только пароль

    // записываем пароль в файл архива
    fwrite(password, sizeof(char), sizeof(password), rest_arch);
    // отграничиваем информацию о пароле в рабочей директории
    fprintf(rest_arch, "-----\n");

    // переносим информацию о папках через функцию переноса
    transfer_content(way_arch, rest_arch);
    // отграничиваем информацию о каталогах в рабочей директории
    fprintf(rest_arch, "-----\n");

    // переносим информацию о файлах через функцию переноса
    transfer_content(gen_arch, rest_arch);
    // отграничиваем информацию о файлах в рабочей директории
    fprintf(rest_arch, "-----\n");

    // переносим информацию о содержимом файлов через функцию переноса
    transfer_content(data_arch, rest_arch);

    // закрываем все открытые ранее файлы
    fclose(gen_arch);
    fclose(data_arch);
    fclose(way_arch);
    fclose(rest_arch);

    // удаление вспомогательной директории "sources" и вспомогательных файлов в ней
    remove_directory(strcat(directory_copy, "/sources"));

    // уведомление об успехе архивации
    printf("\t\t\t\t    \033[35m Архивация завершена успешно!\033[0m");
    return ;                                           // возвращаем обещанное значение функцией                 
}



/*----------------------------------------------------------------------*/
/*     Доступность файла по указанному пути    */
/*---------------------------------------------*/

bool check_file_access(const char* file_path)          // путь к файлу

{
    FILE* file = fopen(file_path, "r");                // открываем файл с использованием функции для чтения
    
    // файл не открылся 
    if (file == NULL) 
    {
        return false;                                  // возвращаем флаг неудачи
    }// if(file == NULL) 
    
    fclose(file);                                      // если файл открылся, значит он доступен, проверили - закрываем
    return true;                                       // возвращаем флаг удачи
}



/*----------------------------------------------------------------------*/
/*      Проверка расширения файла на архив     */
/*---------------------------------------------*/

bool check_file_extension(const char* file_name)       // путь к файлу
{
    const char* extension = ".linrar";                 // расширение, которое проверяется
    size_t extension_length = strlen(extension);       // длина строки расширения
    size_t file_name_length = strlen(file_name);       // длина пути к файлу
    
    if (file_name_length < extension_length)           // длина пути к файлу меньше, чем длина расширения
    {
        return false;                                  // сразу ошибка. Возвращаем флаг ошибки
    }// if(file_name_length < extension_length) 

    // указатель на символ расширения файла
    // вычисляется путем добавления разницы между длиной имени файла (file_name_length) и длиной расширения (extension_length) к началу строки file_name.
    const char* file_extension = file_name + (file_name_length - extension_length);

    // расширение файла совпадает с нужным нам
    if (strcmp(file_extension, extension) == 0) 
    {
        return true;                                   // возвращаем флаг успеха
    }// if (strcmp(file_extension, extension) == 0)

    return false;                                      // иначе расширение не совпадает -> файл не архив. Флаг ошибки
}



/*----------------------------------------------------------------------*/
/*      обход и запись путей     */
/*-------------------------------*/

void write_dir(const char *dir,                        // путь к директории, которую нужно обойти и записать файлы
               int *count_files,                       // указатель на переменную, в которой будет сохранено общее количество файлов в директории и ее поддиректориях
               char (*file_paths)[256])                // двумерный массив символов размером [256][], в котором будут сохранены пути ко всем файлам
{
    DIR *dp;                                           // указатель на структуру директории
    struct dirent *entry;                              // указатель на структуру сведений о файле или поддиректории
    struct stat statbuf;                               // структура, хранящая информацию о сведениях о файле или поддиректории

    // попытка открыть директорию
    if ((dp = opendir(dir)) == NULL) 
    {
        // ошибка открытия
        printf("\n\033[35m ОШИБКА открытия существующей директории %s. Код ошибки -9.\033[0m\n\n", dir);
        return;                                        // возвращаем обещанное значение
    }// if((dp = opendir(dir)) == NULL) 

    chdir(dir);                                        // меняем рабочий каталог

    // чтение каждой записи в директории
    while ((entry = readdir(dp)) != NULL) 
    {
        // получение информации о файле или поддиректории
        lstat(entry->d_name, &statbuf);

        // проверка, является ли элемент директорией
        if (S_ISDIR(statbuf.st_mode)) 
        {
            // пропустить текущий и родительский каталоги
            if (strcmp(".", entry->d_name) == 0 || strcmp("..", entry->d_name) == 0) 
            {
                continue;
            }// if (strcmp(".", entry->d_name) == 0 || strcmp("..", entry->d_name) == 0)

            // соединяем путь к директории с именем вложенной директории
            char next_dir[256];
            sprintf(next_dir, "%s/%s", dir, entry->d_name);

            // рекурсивный вызов для вложенной директории
            write_dir(next_dir, count_files, file_paths);
        } 
        
        else 
        {
            // соединяем путь к родительской директории с именем файла
            sprintf(file_paths[*count_files], "%s/%s", dir, entry->d_name);
            (*count_files)++;                          // переходим к следующему элементу массива

        }// if (S_ISDIR(statbuf.st_mode))

    }// while()

    chdir("..");                                       // возвращаемся в родительский каталог
    closedir(dp);                                      // закрываем директорию
    return ;                                           // возвращаем обещанное значение
} 



/*----------------------------------------------------------------------*/
/*     Разархиватор    */
/*---------------------*/

void unarchiver()
{
    char file_path[256];                       // путь до файла-архива
    memset(file_path, 0, sizeof(file_path));   // очистка массива пути

    printf(" Введите путь до файла-архива: ");
    scanf(" %s", file_path);                   // ввод пути до файла-архива

    // бесконечный цикл ввода и проверки
    while(true)
    {
        // проверка доступа к файлу
        if (check_file_access(file_path)) 
        {
            
            // проверка, что файл - архив .linrar
            if (check_file_extension(file_path)) 
            {
                printf("\033[38;5;222m Доступ к файлу возможен, и расширение в названии файла является '.linrar' \033[0m\n");
                printf("\033[38;5;219m Файл может быть доступен для разархивации \033[0m\n\n");
                break;                         // выходим из цикла ввода
            } 

            // иначе-ошибка ввода
            else 
            {
                char choice[10];               // выбор повтора ввода
                printf("\033[38;5;222m Доступ к файлу возможен, но расширение в названии файла не является '.librar'\033[0m\n\n");
                printf(" Хотите попробовать указать путь ещё раз? (Y/N): ");
                scanf("%9s", choice);
                printf("\n");

                // пользователь выбрал ввести другой адрес до архива
                if((strcmp(choice, "Y") == 0) || (strcmp(choice, "y") == 0))
                {
                    printf(" **********\n");
                    printf(" Введите путь до файла-архива: ");
                    scanf(" %s", file_path);
                    continue;                  // запускаем цикл заново и проверяем файл на архив
                }
                
                // пользователь не захотел вводить новый путь до архива
                else
                {
                    printf("\033[35m ОШИБКА! Введённый Вами файл невозможно разорхивировать. Код ошибки -10. \033[0m \n");
                    return;                    // заканчиваем функцию
                }// if((strcmp(choice, "Y") == 0) || (strcmp(choice, "y") == 0))

            }// if (check_file_extension(file_path)) 
        }

        else 
        {
            printf("\n\033[35m ОШИБКА! Доступ к файлу %s невозможен. Код ошибки -11.\033[0m \n", file_path);
            return;                            // заканчиваем функцию
        }// if (check_file_access(file_path)) 

    }// while()

        
    FILE *rest_arch = fopen(file_path, "rb");  // открытие файла архива

    // ошибка открытия
    if (rest_arch == NULL) 
    {
        printf("\n\033[35m ОШИБКА открытия архива \"%s\" для разархивации. Код ошибки -12. \033[0m \n", rest_arch);
        return;                               // заканчиваем функцию
    }// if (rest_arch == NULL)

    // проверка пароля для разархивации
    char buffer[100];
    // очистка массива пароля, считанного из архива
    memset(buffer, 0, sizeof(buffer));
    // читаем пароль из архива
    fgets(buffer, sizeof(buffer), rest_arch);
    // размер строки с паролем до символа "\n"
    size_t buffer_length = strcspn(buffer, "\n");
    
    // бесконечный цикл ввода пароля пользователем
    while(true)
    {
        char password_user[100];              // пароль, вводимый пользователем
        // очистка массива, в котором хранится введённый пароль
        memset(password_user, 0, sizeof(password_user));
        printf(" Введите пароль от архива для разархивации. Для выхода введите exit: ");
        scanf("%s", password_user);           // ввод пароля в очищенный массив

        // буквенные значения паролей совпали до символа перевода строки и длина введённой пользователем строки равна строке пароля без символа переноса
        if((strncmp(password_user, buffer, buffer_length) == 0) && (strlen(password_user) == buffer_length))
        {
            printf("\033[38;5;205m Разархивация разрешена. Пароли совпали.\033[0m\n");
            // читаем строку символов-разделителей
            fgets(buffer, sizeof(buffer), rest_arch);
            break;                            // пароль успешно введён. Заканчиваем цикл
        }

        // пользователь не значет пароль. Вводит выход
        else if (strcmp(password_user, "exit") == 0)
        {
            // программа разархиватора завершается из функции
            printf(" Возвращайтесь, когда узнаете пароль :D");
            printf("\n\n\t\t\t\t      \033[35m Разархивация завершена!\033[0m");
            return;                           // возвращаем обещанное значение
        }

        // пользователь ввёл неверный пароль. Уведомляем. Повторяем ввод
        else
        {
            printf(" Пароли не совпали. Повторите ввод\n");
            printf(" -----\n");
        }// if

    }// while()  

    char directory[256];               // ввод директории, куда будем разархивировать
    // очистка массива
    memset(directory, 0, sizeof(directory));

    printf("\n");
    // устанавливаем директорию, куда будет проходить разархивация
    changeDirectory(directory, "/home/dmitru/Lab_Examples/Lab1_repack");
    create_directory(directory, "");   // создание директории по заданному адресу, куда будем разархивировать
    printf("\n");

    // создание папок и файлов в директории разархивации
    char line[256];
    memset(line, 0, sizeof(line));     // очистка массива
   
    int counter = 0;                   // счетчик для подсчитывания разделителей
    int count_files = 0;               // счетчик для подсчёта количества файлов, но не каталогов
    int cycle = 0;                     // счётчик вывода надписей в цикле
    
    printf("\033[38;5;120m Объекты, перенесённые из архива: \033[0m\n");
    // работа с папками и файлами
    // считываем построчно
    while (fgets(line, sizeof(line), rest_arch)) 
    {
        // попали на символ-разделитель
        if (strcmp(line, "-----\n") == 0) 
        {
            printf(" -----------------\n Всего: %i \n\n", cycle);
            cycle = 0;                 // для вывода новой надписи
            counter = counter +1;      // увеличили счетчик разделителей
           
            if(counter == 2)           // прошли два разделителя. Далее уже информация из файлов. ничего создавать не надо
            {
                break;                 // заканчиваем цикл создания и переходим к циклу заполнения
            }// if(counter == 2) 

            continue;                  // пропускаем строку с символами-разделителями
        }// if (strcmp(line, "-----\n") == 0) 

        // находим позицию символа новой строки
        size_t newLinePos = strcspn(line, "\n"); 
        
        // убираем символ перевода строки
        // заменяем символ новой строки на символ окончания строки
        if (line[newLinePos] == '\n') 
        {
            line[newLinePos] = '\0';
        }// if (line[newLinePos] == '\n') 

        // определяем название и путь
        char* firstChar = strchr(line, ','); // находим первое вхождение запятой в строке
        char directoryName[256];             // название директории/файла

        // запятая-разделитель в строке найдена
        if (firstChar) 
        {
            size_t length = firstChar - line;                // вычисляем длину первого слова. Разность между указателем на начало строки и указателем на символ ','
            memset(directoryName, 0, sizeof(directoryName)); // очистка массива
            strncpy(directoryName, line, length);            // копируем первое слово в новую переменную
        
        }// if(firstChar) 


        char directoryPath[256];                             // путь к директории/файлу
        memset(directoryPath, 0, sizeof(directoryPath));     // очистка массива пути
        strcpy(directoryPath, directory);                    // первоначально копируем адрес директории разархивации
        strcat(directoryPath, "/");

        char* slashPos = strchr(line, '/');                  // определяем позицию первого символа '/'. Всё, что после - адрес каталога/файла 
        char address[256];                                   // часть адреса после первого символа '/'           
        memset(address, 0, sizeof(address));                 // очистка массива
        
        if (slashPos) 
        {
            strcpy(address, slashPos + 1);                   // копируем часть адреса после первого символа '/'
        } 

        // иначе - копируем строку непосредственно целиком
        else 
        {
            strcpy(address, line);
        }// if (slashPos) 

        // собираем путь до директории разархивации + путь к файлу/каталогу внутри архива
        strcat(directoryPath, address);

        // нету символов-разделителей: создаём директории
        if(counter == 0)
        {
            // создаём директорию по указанному пути
            if (mkdir(directoryPath, 0777) != 0) 
            {
                printf("\n\033[35m ОШИБКА создания директории при разархивации: %s. Код ошибки -13.\033[0m\n", directoryPath);
                return;                                      // возвращаем обещанное функцией значение
            }// if (mkdir(directoryPath, 0777) != 0)

            cycle = cycle + 1;

            // печать надписи каталогов
            if(cycle == 1)
            {
                printf(" Каталоги: \n");
            }// if(cycle == 1)

            // выводим названия каталогов и их путей в архиве
            printf(" %i.      %20s       %s\n", cycle, directoryName, directoryPath);
        }// if(counter == 0)

        // пройден один символ-разделитель: создаём файлы
        else if(counter == 1) 
        {
            // создаём файл по указанному пути
            if(fopen(directoryPath, "w") == 0)
            {
                printf("\n\033[35m ОШИБКА создания файла \"%s\" при разархивации. Код ошибки -14.\033[0m\n", directoryPath);
                return;                                      // возвращаем обещанное функцией значение
            
            }// if(fopen(directoryPath, "w") == 0)

            cycle = cycle + 1;
            // печать надписи файлов
            if(cycle == 1)
            {
                printf(" Файлы: \n");
            }// if(cycle == 1)
            // выводим названия каталогов и их путей в архиве
            printf(" %i.      %20s       %s\n", cycle, directoryName, directoryPath);

        }// else if(counter == 1) 

    }// while()

    printf("\033[38;5;105m Иерархия объектов в директории разархивации: \033[0m\n");
    // запись информации в файлы. Для начала определим их количество
    print_dir(directory, 0, &count_files);
    // выводим количество файлов, в которые подлежит запись информации
    printf("\n Количество заполняемых файлов в директории: %i\n\n", count_files);
    printf("\033[38;5;223m Пути до заполняемых файлов: \033[0m\n");
    
    char file_paths[count_files][256];                       // создаём массив для записи файлов в порядке обхода, т.е. так, в каком порядке информация о них содержится в архиве
    
    count_files = 0;                                         // обнуляем счётчик для индексации и записи
    write_dir(directory, &count_files, file_paths);          // определяем порядок обхода файлов для записи в архив

    // выводим пути к файлам в порядке обхода
    for (int i = 0; i < count_files; i++) 
    {
        printf(" %s\n", file_paths[i]);                      // выводим пути до файлов в директории разархивации в порядке обхода
    }// for i

    int i = 0;
    FILE *write_file;                                        // файловая переменная для открытия файлов для записи

    // запись данных в файлы построчно
    while (fgets(line, sizeof(line), rest_arch) != NULL) 
    {
        // файл для записи не открыт
        if(write_file==NULL)
        {
            write_file = fopen(file_paths[i], "wb");         // открываем очередной файл из массива, в который будем записывать информацию
            
            // файл записи не открылся
            if (write_file == NULL) 
            {
                printf("\n\033[35m ОШИБКА открытия файла разархивации\"%s\" для записи информации. Код ошибки -15 \033[0m\n", write_file);
                exit (0);                                    // заканчиваем программу 
            }// if (write_file == NULL) 

        }// if(write_file==NULL)

        // иначе файл для записи открыт
        // нашли символ-разделитель между информацией для записи в разные файлы
        if (strcmp(line, "*****\n") == 0) 
        {
            // запись локального времени только в текстовые выходные файлы
            char *txt_ext = ".txt";                          // объявление переменной txt_ext типа "указатель на символ"
            int filenameIN_len = strlen(file_paths[i]);      // размер пути до файла считывания
            int txt_ext_len = strlen(txt_ext);               // значение, равное длине строки txt_ext, которая представляет расширение файла .txt.
   
            // длина имени файла (filenameIN_len) больше или равна длине расширения .txt (txt_ext_len).
            // Если это условие не выполняется, значит длина имени файла слишком короткая, чтобы содержать
            // расширение .txt, и дальнейшая проверка не имеет смысла

            // сравнивает часть имени файла, начиная с позиции filenameIN_len - txt_ext_len и имеющей длину txt_ext_len, с расширением .txt (txt_ext)
            if (filenameIN_len >= txt_ext_len && strcmp(file_paths[i] + filenameIN_len - txt_ext_len, txt_ext) == 0) 
            {
                time_t now = time(NULL);                     // переменная времени
                struct tm *local_time = localtime(&now);     // получение локального времени
                fprintf(write_file, "Дата и время разархивации: %02d/%02d/%04d %02d:%02d:%02d\n",
                local_time->tm_mday, local_time->tm_mon + 1, local_time->tm_year + 1900,
                local_time->tm_hour, local_time->tm_min, local_time->tm_sec);
            }// if(filenameIN_len >= txt_ext_len && strcmp(file_paths[i] + filenameIN_len - txt_ext_len, txt_ext) == 0) 
            
            i=i+1;                                           // нашли разделитель - перешли к следующему файлу для записи
            fclose(write_file);                              // закрыли текущий файл
            write_file=NULL;                                 // убираем указатель на NULL
            continue;                                        // разделитель в файл не записываем - начинаем цикл сначала
        }// if (strcmp(line, "*****\n") == 0)

        // если строка - не разделитель
        fputs(line, write_file);                             // записываем строку в открытый файл для записи
    }// while()

    printf("\n\t\t\t\t    \033[35m Разархивация завершена успешно!\033[0m");
    return;                                                  // возвращаем обещанное значение
}



/*----------------------------------------------------------------------*/
/*         Очистка буфера ввода          */
/*---------------------------------------*/
void clearInputBuffer() 
{
    int c;

    // чтение символов из входного буфера до тех пор, пока не будет достигнут символ новой строки ('\n') или конец файла (EOF) 
    while ((c = getchar()) != '\n' && c != EOF) { }

    // символ равен новой строке или концу файла, while-цикл завершается. Управление передаётся основной функции
    return;
}




/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/
int main()
{
    bool continueLoop = true;                // метка опродолжения для бесконечного цикла switch

    // бесконечный цикл работы с архивами до момента выбора "выхода" пользователем
    while(continueLoop)
    {

        // при каждом новом цикле запуска выводим название архиватора
        printf("\n\n");
        printf("                   ______   _______  _______  _______  _______  _______  _______  \n");
        printf("                  (  __  \\ (  ____ \\(  ___  )(       )(  ____ \\(  __   )(  __   ) \n");
        printf("                  | (  \\  )| (    \\/| (   ) || () () || (    \\/| (  )  || (  )  | \n");
        printf("     ____   ____  | |   ) || |      | |   | || || || || (__    | | /   || | /   |  ____   ____ \n");
        printf("    (____) (____) | |   | || |      | |   | || |(_)| ||  __)   | (/ /) || (/ /) | (____) (____)\n");
        printf("                  | |   ) || |      | |   | || |   | || (      |   / | ||   / | | \n");
        printf("                  | (__/  )| (____/\\| (___) || )   ( || (____/\\|  (__) ||  (__) | \n");
        printf("                  (______/ (_______/(_______)|/     \\|(_______/(_______)(_______) \n");
        
        // вывод на экран приветствия
        printf("\n\n\t\t        \033[35m Добро пожаловать в программу для работы с архивами!\033[0m\n\n\n");
        printf("\033[36m Выберите действие. Введите необходимую букву:\033[0m\n\n");
        printf("      \033[37m a - Архивировать;\033[0m    \033[34m b - Разархивировать;\033[0m    \033[31m c - Завершить выполнение программы;\033[0m\n\n");
        printf(" Ввод: ");
        
        char choice[6];                      // выбор действия пользователем
        scanf("%5s", choice);                // ввод выбора пользователя с учетом символа окончания '\0'
        clearInputBuffer();                  // очистка буфера ввода перед ожиданием нажатия символа
        printf(" Вы ввели: %5s", choice);    // эхо-печать
        printf("\n");
        
        // выбор пользователся должен состоять из одной буквы
        if(strlen(choice) == 1)
        {
            // проверяем, что выбрал пользователь
            switch(*choice)
            {
                // выбрана архивация
                case 'a':
                case 'A':
                    // вызов функции архивации
                    archiver();
                    // очистка буфера ввода перед ожиданием нажатия символа
                    clearInputBuffer();
                    // ожидание нажатия символа перед очисткой экрана
                    getchar();
                    // очистка экрана
                    system ("clear");
                break;

                // выбрана разархивация
                case 'b':
                case 'B':
                    // вызов функции разархивации
                    unarchiver();
                    // очистка буфера ввода перед ожиданием нажатия символа
                    clearInputBuffer();
                    // ожидание нажатия символа перед очисткой экрана
                    getchar();
                    // очистка экрана
                    system ("clear");
                break;

                // выбран выход из программы
                case 'c':
                case 'C':
                    // убираем метку продолжения цикла
                    continueLoop = false;
                break;

                // если введена буква не из предложенного списка, то выводим сообщение об ошибке
                default:
                    printf("\n\033[35m ОШИБКА выбора действия. Повторите ввод. Код ошибки -3.\033[0m");
                    // ожидание нажатия символа перед очисткой экрана
                    getchar();
                    // очистка экрана
                    system ("clear");
                break;

            }// switch
        }

        else
        {
            printf("\n\033[35m ОШИБКА выбора действия. Повторите ввод. Код ошибки -3.\033[0m");
            getchar();
            system ("clear");
        }// if(strlen(choice) == 1)

    }// while

    // ascii-арт на экране после окончания программы
    printf("\n\t\t\t\t   \033[35m Завершение работы программы!\033[0m\n\n");
    printf("⠀\t\t\t\t       ⠀⠀⠀⠀⠀⢀⣠⣤⠤⠤⢤⣤⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀\n");
    printf("⠀\t\t\t\t       ⠀⠀⣠⣴⣾⡿⠛⠁⠀⠀⠀⠈⠛⠛⠿⣷⣄⡀⠀⠀⠀⠀\n");
    printf("\t\t\t\t       ⠀⢀⣴⠟⠋⢁⢤⠴⠚⠉⠉⠉⠀⠀⠉⢲⡄⠈⠳⣄⠀⠀\n");
    printf("\t\t\t\t       ⠠⣾⠟⠁⠀⡾⠁⠀⠀⠀⠀⠀⠀⢠⡀⠈⠙⣆⢀⢸⡆⠀\n");
    printf("\t\t\t\t       ⣸⠇⠀⠀⠀⢿⣇⠀⠀⢸⡏⠦⢤⡞⢴⣄⠀⠈⣾⠇⠀⠀\n");
    printf("\t\t\t\t       ⣿⠀⠠⡴⠋⠈⠛⠻⠿⠶⢿⣇⣼⠾⡿⠟⠻⠛⠁⠀⠀⠀\n");
    printf("\t\t\t\t       ⠸⣦⣼⠀⠀⠀⠀⠀⠤⠄⢸⣿⠁⠀⠀⠀⠀⠀⢀⣠⠇⠀\n");
    printf("\t\t\t\t⠀       ⠉⠻⢿⡀⠀⠀⠀⢀⡠⢊⠸⠇⠀⠀⠀⡀⠄⣠⠞⠀⠀\n");
    printf("\t\t\t\t⠀⠀       ⠀⠘⡆⠀⠄⢸⣾⣋⡁⢀⡀⠀⠀⢠⡿⠁⠀⠀⠀⠀\n");
    printf("\t\t\t\t       ⠀⠀⠀⠀⠈⠳⢄⡉⠁⠸⡇⠀⠈⠳⡄⢸⠇⠀⠀⠀⠀⠀\n");
    printf("\t\t\t\t⠀⠀⠀⠀⠀       ⠀⠀⠈⠛⠀⠀⠀⠀⠈⠛⠁⠀⠀⠀⠀⠀⠀\n\n\n");

    return 0;                                // возвращаем обещанное при объявлении значение
}// main()